// Code generated by mockery v2.31.1. DO NOT EDIT.

package store

import (
	context "context"

	eventbus "github.com/observiq/bindplane-op/eventbus"
	mock "github.com/stretchr/testify/mock"

	model "github.com/observiq/bindplane-op/model"

	search "github.com/observiq/bindplane-op/store/search"

	sessions "github.com/gorilla/sessions"

	stats "github.com/observiq/bindplane-op/store/stats"

	time "time"
)

// mockStore is an autogenerated mock type for the Store type
type mockStore struct {
	mock.Mock
}

type mockStore_Expecter struct {
	mock *mock.Mock
}

func (_m *mockStore) EXPECT() *mockStore_Expecter {
	return &mockStore_Expecter{mock: &_m.Mock}
}

// Agent provides a mock function with given fields: ctx, id
func (_m *mockStore) Agent(ctx context.Context, id string) (*model.Agent, error) {
	ret := _m.Called(ctx, id)

	var r0 *model.Agent
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.Agent, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.Agent); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Agent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_Agent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Agent'
type mockStore_Agent_Call struct {
	*mock.Call
}

// Agent is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *mockStore_Expecter) Agent(ctx interface{}, id interface{}) *mockStore_Agent_Call {
	return &mockStore_Agent_Call{Call: _e.mock.On("Agent", ctx, id)}
}

func (_c *mockStore_Agent_Call) Run(run func(ctx context.Context, id string)) *mockStore_Agent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_Agent_Call) Return(_a0 *model.Agent, _a1 error) *mockStore_Agent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_Agent_Call) RunAndReturn(run func(context.Context, string) (*model.Agent, error)) *mockStore_Agent_Call {
	_c.Call.Return(run)
	return _c
}

// AgentConfiguration provides a mock function with given fields: ctx, agent
func (_m *mockStore) AgentConfiguration(ctx context.Context, agent *model.Agent) (*model.Configuration, error) {
	ret := _m.Called(ctx, agent)

	var r0 *model.Configuration
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.Agent) (*model.Configuration, error)); ok {
		return rf(ctx, agent)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.Agent) *model.Configuration); ok {
		r0 = rf(ctx, agent)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Configuration)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.Agent) error); ok {
		r1 = rf(ctx, agent)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_AgentConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentConfiguration'
type mockStore_AgentConfiguration_Call struct {
	*mock.Call
}

// AgentConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - agent *model.Agent
func (_e *mockStore_Expecter) AgentConfiguration(ctx interface{}, agent interface{}) *mockStore_AgentConfiguration_Call {
	return &mockStore_AgentConfiguration_Call{Call: _e.mock.On("AgentConfiguration", ctx, agent)}
}

func (_c *mockStore_AgentConfiguration_Call) Run(run func(ctx context.Context, agent *model.Agent)) *mockStore_AgentConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.Agent))
	})
	return _c
}

func (_c *mockStore_AgentConfiguration_Call) Return(_a0 *model.Configuration, _a1 error) *mockStore_AgentConfiguration_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_AgentConfiguration_Call) RunAndReturn(run func(context.Context, *model.Agent) (*model.Configuration, error)) *mockStore_AgentConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// AgentIndex provides a mock function with given fields: ctx
func (_m *mockStore) AgentIndex(ctx context.Context) search.Index {
	ret := _m.Called(ctx)

	var r0 search.Index
	if rf, ok := ret.Get(0).(func(context.Context) search.Index); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(search.Index)
		}
	}

	return r0
}

// mockStore_AgentIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentIndex'
type mockStore_AgentIndex_Call struct {
	*mock.Call
}

// AgentIndex is a helper method to define mock.On call
//   - ctx context.Context
func (_e *mockStore_Expecter) AgentIndex(ctx interface{}) *mockStore_AgentIndex_Call {
	return &mockStore_AgentIndex_Call{Call: _e.mock.On("AgentIndex", ctx)}
}

func (_c *mockStore_AgentIndex_Call) Run(run func(ctx context.Context)) *mockStore_AgentIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *mockStore_AgentIndex_Call) Return(_a0 search.Index) *mockStore_AgentIndex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *mockStore_AgentIndex_Call) RunAndReturn(run func(context.Context) search.Index) *mockStore_AgentIndex_Call {
	_c.Call.Return(run)
	return _c
}

// AgentVersion provides a mock function with given fields: ctx, name
func (_m *mockStore) AgentVersion(ctx context.Context, name string) (*model.AgentVersion, error) {
	ret := _m.Called(ctx, name)

	var r0 *model.AgentVersion
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.AgentVersion, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.AgentVersion); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.AgentVersion)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_AgentVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentVersion'
type mockStore_AgentVersion_Call struct {
	*mock.Call
}

// AgentVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *mockStore_Expecter) AgentVersion(ctx interface{}, name interface{}) *mockStore_AgentVersion_Call {
	return &mockStore_AgentVersion_Call{Call: _e.mock.On("AgentVersion", ctx, name)}
}

func (_c *mockStore_AgentVersion_Call) Run(run func(ctx context.Context, name string)) *mockStore_AgentVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_AgentVersion_Call) Return(_a0 *model.AgentVersion, _a1 error) *mockStore_AgentVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_AgentVersion_Call) RunAndReturn(run func(context.Context, string) (*model.AgentVersion, error)) *mockStore_AgentVersion_Call {
	_c.Call.Return(run)
	return _c
}

// AgentVersions provides a mock function with given fields: ctx
func (_m *mockStore) AgentVersions(ctx context.Context) ([]*model.AgentVersion, error) {
	ret := _m.Called(ctx)

	var r0 []*model.AgentVersion
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*model.AgentVersion, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*model.AgentVersion); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.AgentVersion)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_AgentVersions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentVersions'
type mockStore_AgentVersions_Call struct {
	*mock.Call
}

// AgentVersions is a helper method to define mock.On call
//   - ctx context.Context
func (_e *mockStore_Expecter) AgentVersions(ctx interface{}) *mockStore_AgentVersions_Call {
	return &mockStore_AgentVersions_Call{Call: _e.mock.On("AgentVersions", ctx)}
}

func (_c *mockStore_AgentVersions_Call) Run(run func(ctx context.Context)) *mockStore_AgentVersions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *mockStore_AgentVersions_Call) Return(_a0 []*model.AgentVersion, _a1 error) *mockStore_AgentVersions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_AgentVersions_Call) RunAndReturn(run func(context.Context) ([]*model.AgentVersion, error)) *mockStore_AgentVersions_Call {
	_c.Call.Return(run)
	return _c
}

// Agents provides a mock function with given fields: ctx, options
func (_m *mockStore) Agents(ctx context.Context, options ...QueryOption) ([]*model.Agent, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []*model.Agent
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...QueryOption) ([]*model.Agent, error)); ok {
		return rf(ctx, options...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...QueryOption) []*model.Agent); ok {
		r0 = rf(ctx, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Agent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...QueryOption) error); ok {
		r1 = rf(ctx, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_Agents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Agents'
type mockStore_Agents_Call struct {
	*mock.Call
}

// Agents is a helper method to define mock.On call
//   - ctx context.Context
//   - options ...QueryOption
func (_e *mockStore_Expecter) Agents(ctx interface{}, options ...interface{}) *mockStore_Agents_Call {
	return &mockStore_Agents_Call{Call: _e.mock.On("Agents",
		append([]interface{}{ctx}, options...)...)}
}

func (_c *mockStore_Agents_Call) Run(run func(ctx context.Context, options ...QueryOption)) *mockStore_Agents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]QueryOption, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(QueryOption)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *mockStore_Agents_Call) Return(_a0 []*model.Agent, _a1 error) *mockStore_Agents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_Agents_Call) RunAndReturn(run func(context.Context, ...QueryOption) ([]*model.Agent, error)) *mockStore_Agents_Call {
	_c.Call.Return(run)
	return _c
}

// AgentsCount provides a mock function with given fields: _a0, _a1
func (_m *mockStore) AgentsCount(_a0 context.Context, _a1 ...QueryOption) (int, error) {
	_va := make([]interface{}, len(_a1))
	for _i := range _a1 {
		_va[_i] = _a1[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...QueryOption) (int, error)); ok {
		return rf(_a0, _a1...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...QueryOption) int); ok {
		r0 = rf(_a0, _a1...)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...QueryOption) error); ok {
		r1 = rf(_a0, _a1...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_AgentsCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentsCount'
type mockStore_AgentsCount_Call struct {
	*mock.Call
}

// AgentsCount is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 ...QueryOption
func (_e *mockStore_Expecter) AgentsCount(_a0 interface{}, _a1 ...interface{}) *mockStore_AgentsCount_Call {
	return &mockStore_AgentsCount_Call{Call: _e.mock.On("AgentsCount",
		append([]interface{}{_a0}, _a1...)...)}
}

func (_c *mockStore_AgentsCount_Call) Run(run func(_a0 context.Context, _a1 ...QueryOption)) *mockStore_AgentsCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]QueryOption, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(QueryOption)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *mockStore_AgentsCount_Call) Return(_a0 int, _a1 error) *mockStore_AgentsCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_AgentsCount_Call) RunAndReturn(run func(context.Context, ...QueryOption) (int, error)) *mockStore_AgentsCount_Call {
	_c.Call.Return(run)
	return _c
}

// AgentsIDsMatchingConfiguration provides a mock function with given fields: ctx, conf
func (_m *mockStore) AgentsIDsMatchingConfiguration(ctx context.Context, conf *model.Configuration) ([]string, error) {
	ret := _m.Called(ctx, conf)

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.Configuration) ([]string, error)); ok {
		return rf(ctx, conf)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.Configuration) []string); ok {
		r0 = rf(ctx, conf)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.Configuration) error); ok {
		r1 = rf(ctx, conf)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_AgentsIDsMatchingConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentsIDsMatchingConfiguration'
type mockStore_AgentsIDsMatchingConfiguration_Call struct {
	*mock.Call
}

// AgentsIDsMatchingConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - conf *model.Configuration
func (_e *mockStore_Expecter) AgentsIDsMatchingConfiguration(ctx interface{}, conf interface{}) *mockStore_AgentsIDsMatchingConfiguration_Call {
	return &mockStore_AgentsIDsMatchingConfiguration_Call{Call: _e.mock.On("AgentsIDsMatchingConfiguration", ctx, conf)}
}

func (_c *mockStore_AgentsIDsMatchingConfiguration_Call) Run(run func(ctx context.Context, conf *model.Configuration)) *mockStore_AgentsIDsMatchingConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.Configuration))
	})
	return _c
}

func (_c *mockStore_AgentsIDsMatchingConfiguration_Call) Return(_a0 []string, _a1 error) *mockStore_AgentsIDsMatchingConfiguration_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_AgentsIDsMatchingConfiguration_Call) RunAndReturn(run func(context.Context, *model.Configuration) ([]string, error)) *mockStore_AgentsIDsMatchingConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// ApplyResources provides a mock function with given fields: ctx, resources
func (_m *mockStore) ApplyResources(ctx context.Context, resources []model.Resource) ([]model.ResourceStatus, error) {
	ret := _m.Called(ctx, resources)

	var r0 []model.ResourceStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []model.Resource) ([]model.ResourceStatus, error)); ok {
		return rf(ctx, resources)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []model.Resource) []model.ResourceStatus); ok {
		r0 = rf(ctx, resources)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.ResourceStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []model.Resource) error); ok {
		r1 = rf(ctx, resources)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_ApplyResources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApplyResources'
type mockStore_ApplyResources_Call struct {
	*mock.Call
}

// ApplyResources is a helper method to define mock.On call
//   - ctx context.Context
//   - resources []model.Resource
func (_e *mockStore_Expecter) ApplyResources(ctx interface{}, resources interface{}) *mockStore_ApplyResources_Call {
	return &mockStore_ApplyResources_Call{Call: _e.mock.On("ApplyResources", ctx, resources)}
}

func (_c *mockStore_ApplyResources_Call) Run(run func(ctx context.Context, resources []model.Resource)) *mockStore_ApplyResources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]model.Resource))
	})
	return _c
}

func (_c *mockStore_ApplyResources_Call) Return(_a0 []model.ResourceStatus, _a1 error) *mockStore_ApplyResources_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_ApplyResources_Call) RunAndReturn(run func(context.Context, []model.Resource) ([]model.ResourceStatus, error)) *mockStore_ApplyResources_Call {
	_c.Call.Return(run)
	return _c
}

// CleanupDisconnectedAgents provides a mock function with given fields: ctx, since
func (_m *mockStore) CleanupDisconnectedAgents(ctx context.Context, since time.Time) error {
	ret := _m.Called(ctx, since)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, time.Time) error); ok {
		r0 = rf(ctx, since)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// mockStore_CleanupDisconnectedAgents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CleanupDisconnectedAgents'
type mockStore_CleanupDisconnectedAgents_Call struct {
	*mock.Call
}

// CleanupDisconnectedAgents is a helper method to define mock.On call
//   - ctx context.Context
//   - since time.Time
func (_e *mockStore_Expecter) CleanupDisconnectedAgents(ctx interface{}, since interface{}) *mockStore_CleanupDisconnectedAgents_Call {
	return &mockStore_CleanupDisconnectedAgents_Call{Call: _e.mock.On("CleanupDisconnectedAgents", ctx, since)}
}

func (_c *mockStore_CleanupDisconnectedAgents_Call) Run(run func(ctx context.Context, since time.Time)) *mockStore_CleanupDisconnectedAgents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(time.Time))
	})
	return _c
}

func (_c *mockStore_CleanupDisconnectedAgents_Call) Return(_a0 error) *mockStore_CleanupDisconnectedAgents_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *mockStore_CleanupDisconnectedAgents_Call) RunAndReturn(run func(context.Context, time.Time) error) *mockStore_CleanupDisconnectedAgents_Call {
	_c.Call.Return(run)
	return _c
}

// Clear provides a mock function with given fields:
func (_m *mockStore) Clear() {
	_m.Called()
}

// mockStore_Clear_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clear'
type mockStore_Clear_Call struct {
	*mock.Call
}

// Clear is a helper method to define mock.On call
func (_e *mockStore_Expecter) Clear() *mockStore_Clear_Call {
	return &mockStore_Clear_Call{Call: _e.mock.On("Clear")}
}

func (_c *mockStore_Clear_Call) Run(run func()) *mockStore_Clear_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *mockStore_Clear_Call) Return() *mockStore_Clear_Call {
	_c.Call.Return()
	return _c
}

func (_c *mockStore_Clear_Call) RunAndReturn(run func()) *mockStore_Clear_Call {
	_c.Call.Return(run)
	return _c
}

// Close provides a mock function with given fields:
func (_m *mockStore) Close() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// mockStore_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type mockStore_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *mockStore_Expecter) Close() *mockStore_Close_Call {
	return &mockStore_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *mockStore_Close_Call) Run(run func()) *mockStore_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *mockStore_Close_Call) Return(_a0 error) *mockStore_Close_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *mockStore_Close_Call) RunAndReturn(run func() error) *mockStore_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Configuration provides a mock function with given fields: ctx, name
func (_m *mockStore) Configuration(ctx context.Context, name string) (*model.Configuration, error) {
	ret := _m.Called(ctx, name)

	var r0 *model.Configuration
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.Configuration, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.Configuration); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Configuration)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_Configuration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Configuration'
type mockStore_Configuration_Call struct {
	*mock.Call
}

// Configuration is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *mockStore_Expecter) Configuration(ctx interface{}, name interface{}) *mockStore_Configuration_Call {
	return &mockStore_Configuration_Call{Call: _e.mock.On("Configuration", ctx, name)}
}

func (_c *mockStore_Configuration_Call) Run(run func(ctx context.Context, name string)) *mockStore_Configuration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_Configuration_Call) Return(_a0 *model.Configuration, _a1 error) *mockStore_Configuration_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_Configuration_Call) RunAndReturn(run func(context.Context, string) (*model.Configuration, error)) *mockStore_Configuration_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigurationIndex provides a mock function with given fields: ctx
func (_m *mockStore) ConfigurationIndex(ctx context.Context) search.Index {
	ret := _m.Called(ctx)

	var r0 search.Index
	if rf, ok := ret.Get(0).(func(context.Context) search.Index); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(search.Index)
		}
	}

	return r0
}

// mockStore_ConfigurationIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigurationIndex'
type mockStore_ConfigurationIndex_Call struct {
	*mock.Call
}

// ConfigurationIndex is a helper method to define mock.On call
//   - ctx context.Context
func (_e *mockStore_Expecter) ConfigurationIndex(ctx interface{}) *mockStore_ConfigurationIndex_Call {
	return &mockStore_ConfigurationIndex_Call{Call: _e.mock.On("ConfigurationIndex", ctx)}
}

func (_c *mockStore_ConfigurationIndex_Call) Run(run func(ctx context.Context)) *mockStore_ConfigurationIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *mockStore_ConfigurationIndex_Call) Return(_a0 search.Index) *mockStore_ConfigurationIndex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *mockStore_ConfigurationIndex_Call) RunAndReturn(run func(context.Context) search.Index) *mockStore_ConfigurationIndex_Call {
	_c.Call.Return(run)
	return _c
}

// Configurations provides a mock function with given fields: ctx, options
func (_m *mockStore) Configurations(ctx context.Context, options ...QueryOption) ([]*model.Configuration, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []*model.Configuration
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...QueryOption) ([]*model.Configuration, error)); ok {
		return rf(ctx, options...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...QueryOption) []*model.Configuration); ok {
		r0 = rf(ctx, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Configuration)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...QueryOption) error); ok {
		r1 = rf(ctx, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_Configurations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Configurations'
type mockStore_Configurations_Call struct {
	*mock.Call
}

// Configurations is a helper method to define mock.On call
//   - ctx context.Context
//   - options ...QueryOption
func (_e *mockStore_Expecter) Configurations(ctx interface{}, options ...interface{}) *mockStore_Configurations_Call {
	return &mockStore_Configurations_Call{Call: _e.mock.On("Configurations",
		append([]interface{}{ctx}, options...)...)}
}

func (_c *mockStore_Configurations_Call) Run(run func(ctx context.Context, options ...QueryOption)) *mockStore_Configurations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]QueryOption, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(QueryOption)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *mockStore_Configurations_Call) Return(_a0 []*model.Configuration, _a1 error) *mockStore_Configurations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_Configurations_Call) RunAndReturn(run func(context.Context, ...QueryOption) ([]*model.Configuration, error)) *mockStore_Configurations_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAgentVersion provides a mock function with given fields: ctx, name
func (_m *mockStore) DeleteAgentVersion(ctx context.Context, name string) (*model.AgentVersion, error) {
	ret := _m.Called(ctx, name)

	var r0 *model.AgentVersion
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.AgentVersion, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.AgentVersion); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.AgentVersion)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_DeleteAgentVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAgentVersion'
type mockStore_DeleteAgentVersion_Call struct {
	*mock.Call
}

// DeleteAgentVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *mockStore_Expecter) DeleteAgentVersion(ctx interface{}, name interface{}) *mockStore_DeleteAgentVersion_Call {
	return &mockStore_DeleteAgentVersion_Call{Call: _e.mock.On("DeleteAgentVersion", ctx, name)}
}

func (_c *mockStore_DeleteAgentVersion_Call) Run(run func(ctx context.Context, name string)) *mockStore_DeleteAgentVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_DeleteAgentVersion_Call) Return(_a0 *model.AgentVersion, _a1 error) *mockStore_DeleteAgentVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_DeleteAgentVersion_Call) RunAndReturn(run func(context.Context, string) (*model.AgentVersion, error)) *mockStore_DeleteAgentVersion_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAgents provides a mock function with given fields: ctx, agentIDs
func (_m *mockStore) DeleteAgents(ctx context.Context, agentIDs []string) ([]*model.Agent, error) {
	ret := _m.Called(ctx, agentIDs)

	var r0 []*model.Agent
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*model.Agent, error)); ok {
		return rf(ctx, agentIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*model.Agent); ok {
		r0 = rf(ctx, agentIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Agent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, agentIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_DeleteAgents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAgents'
type mockStore_DeleteAgents_Call struct {
	*mock.Call
}

// DeleteAgents is a helper method to define mock.On call
//   - ctx context.Context
//   - agentIDs []string
func (_e *mockStore_Expecter) DeleteAgents(ctx interface{}, agentIDs interface{}) *mockStore_DeleteAgents_Call {
	return &mockStore_DeleteAgents_Call{Call: _e.mock.On("DeleteAgents", ctx, agentIDs)}
}

func (_c *mockStore_DeleteAgents_Call) Run(run func(ctx context.Context, agentIDs []string)) *mockStore_DeleteAgents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *mockStore_DeleteAgents_Call) Return(_a0 []*model.Agent, _a1 error) *mockStore_DeleteAgents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_DeleteAgents_Call) RunAndReturn(run func(context.Context, []string) ([]*model.Agent, error)) *mockStore_DeleteAgents_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteConfiguration provides a mock function with given fields: ctx, name
func (_m *mockStore) DeleteConfiguration(ctx context.Context, name string) (*model.Configuration, error) {
	ret := _m.Called(ctx, name)

	var r0 *model.Configuration
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.Configuration, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.Configuration); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Configuration)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_DeleteConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteConfiguration'
type mockStore_DeleteConfiguration_Call struct {
	*mock.Call
}

// DeleteConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *mockStore_Expecter) DeleteConfiguration(ctx interface{}, name interface{}) *mockStore_DeleteConfiguration_Call {
	return &mockStore_DeleteConfiguration_Call{Call: _e.mock.On("DeleteConfiguration", ctx, name)}
}

func (_c *mockStore_DeleteConfiguration_Call) Run(run func(ctx context.Context, name string)) *mockStore_DeleteConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_DeleteConfiguration_Call) Return(_a0 *model.Configuration, _a1 error) *mockStore_DeleteConfiguration_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_DeleteConfiguration_Call) RunAndReturn(run func(context.Context, string) (*model.Configuration, error)) *mockStore_DeleteConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteDestination provides a mock function with given fields: ctx, name
func (_m *mockStore) DeleteDestination(ctx context.Context, name string) (*model.Destination, error) {
	ret := _m.Called(ctx, name)

	var r0 *model.Destination
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.Destination, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.Destination); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Destination)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_DeleteDestination_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteDestination'
type mockStore_DeleteDestination_Call struct {
	*mock.Call
}

// DeleteDestination is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *mockStore_Expecter) DeleteDestination(ctx interface{}, name interface{}) *mockStore_DeleteDestination_Call {
	return &mockStore_DeleteDestination_Call{Call: _e.mock.On("DeleteDestination", ctx, name)}
}

func (_c *mockStore_DeleteDestination_Call) Run(run func(ctx context.Context, name string)) *mockStore_DeleteDestination_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_DeleteDestination_Call) Return(_a0 *model.Destination, _a1 error) *mockStore_DeleteDestination_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_DeleteDestination_Call) RunAndReturn(run func(context.Context, string) (*model.Destination, error)) *mockStore_DeleteDestination_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteDestinationType provides a mock function with given fields: ctx, name
func (_m *mockStore) DeleteDestinationType(ctx context.Context, name string) (*model.DestinationType, error) {
	ret := _m.Called(ctx, name)

	var r0 *model.DestinationType
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.DestinationType, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.DestinationType); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.DestinationType)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_DeleteDestinationType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteDestinationType'
type mockStore_DeleteDestinationType_Call struct {
	*mock.Call
}

// DeleteDestinationType is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *mockStore_Expecter) DeleteDestinationType(ctx interface{}, name interface{}) *mockStore_DeleteDestinationType_Call {
	return &mockStore_DeleteDestinationType_Call{Call: _e.mock.On("DeleteDestinationType", ctx, name)}
}

func (_c *mockStore_DeleteDestinationType_Call) Run(run func(ctx context.Context, name string)) *mockStore_DeleteDestinationType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_DeleteDestinationType_Call) Return(_a0 *model.DestinationType, _a1 error) *mockStore_DeleteDestinationType_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_DeleteDestinationType_Call) RunAndReturn(run func(context.Context, string) (*model.DestinationType, error)) *mockStore_DeleteDestinationType_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteProcessor provides a mock function with given fields: ctx, name
func (_m *mockStore) DeleteProcessor(ctx context.Context, name string) (*model.Processor, error) {
	ret := _m.Called(ctx, name)

	var r0 *model.Processor
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.Processor, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.Processor); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Processor)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_DeleteProcessor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProcessor'
type mockStore_DeleteProcessor_Call struct {
	*mock.Call
}

// DeleteProcessor is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *mockStore_Expecter) DeleteProcessor(ctx interface{}, name interface{}) *mockStore_DeleteProcessor_Call {
	return &mockStore_DeleteProcessor_Call{Call: _e.mock.On("DeleteProcessor", ctx, name)}
}

func (_c *mockStore_DeleteProcessor_Call) Run(run func(ctx context.Context, name string)) *mockStore_DeleteProcessor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_DeleteProcessor_Call) Return(_a0 *model.Processor, _a1 error) *mockStore_DeleteProcessor_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_DeleteProcessor_Call) RunAndReturn(run func(context.Context, string) (*model.Processor, error)) *mockStore_DeleteProcessor_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteProcessorType provides a mock function with given fields: ctx, name
func (_m *mockStore) DeleteProcessorType(ctx context.Context, name string) (*model.ProcessorType, error) {
	ret := _m.Called(ctx, name)

	var r0 *model.ProcessorType
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.ProcessorType, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.ProcessorType); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.ProcessorType)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_DeleteProcessorType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProcessorType'
type mockStore_DeleteProcessorType_Call struct {
	*mock.Call
}

// DeleteProcessorType is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *mockStore_Expecter) DeleteProcessorType(ctx interface{}, name interface{}) *mockStore_DeleteProcessorType_Call {
	return &mockStore_DeleteProcessorType_Call{Call: _e.mock.On("DeleteProcessorType", ctx, name)}
}

func (_c *mockStore_DeleteProcessorType_Call) Run(run func(ctx context.Context, name string)) *mockStore_DeleteProcessorType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_DeleteProcessorType_Call) Return(_a0 *model.ProcessorType, _a1 error) *mockStore_DeleteProcessorType_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_DeleteProcessorType_Call) RunAndReturn(run func(context.Context, string) (*model.ProcessorType, error)) *mockStore_DeleteProcessorType_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteResources provides a mock function with given fields: ctx, resources
func (_m *mockStore) DeleteResources(ctx context.Context, resources []model.Resource) ([]model.ResourceStatus, error) {
	ret := _m.Called(ctx, resources)

	var r0 []model.ResourceStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []model.Resource) ([]model.ResourceStatus, error)); ok {
		return rf(ctx, resources)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []model.Resource) []model.ResourceStatus); ok {
		r0 = rf(ctx, resources)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.ResourceStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []model.Resource) error); ok {
		r1 = rf(ctx, resources)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_DeleteResources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteResources'
type mockStore_DeleteResources_Call struct {
	*mock.Call
}

// DeleteResources is a helper method to define mock.On call
//   - ctx context.Context
//   - resources []model.Resource
func (_e *mockStore_Expecter) DeleteResources(ctx interface{}, resources interface{}) *mockStore_DeleteResources_Call {
	return &mockStore_DeleteResources_Call{Call: _e.mock.On("DeleteResources", ctx, resources)}
}

func (_c *mockStore_DeleteResources_Call) Run(run func(ctx context.Context, resources []model.Resource)) *mockStore_DeleteResources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]model.Resource))
	})
	return _c
}

func (_c *mockStore_DeleteResources_Call) Return(_a0 []model.ResourceStatus, _a1 error) *mockStore_DeleteResources_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_DeleteResources_Call) RunAndReturn(run func(context.Context, []model.Resource) ([]model.ResourceStatus, error)) *mockStore_DeleteResources_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSource provides a mock function with given fields: ctx, name
func (_m *mockStore) DeleteSource(ctx context.Context, name string) (*model.Source, error) {
	ret := _m.Called(ctx, name)

	var r0 *model.Source
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.Source, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.Source); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Source)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_DeleteSource_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSource'
type mockStore_DeleteSource_Call struct {
	*mock.Call
}

// DeleteSource is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *mockStore_Expecter) DeleteSource(ctx interface{}, name interface{}) *mockStore_DeleteSource_Call {
	return &mockStore_DeleteSource_Call{Call: _e.mock.On("DeleteSource", ctx, name)}
}

func (_c *mockStore_DeleteSource_Call) Run(run func(ctx context.Context, name string)) *mockStore_DeleteSource_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_DeleteSource_Call) Return(_a0 *model.Source, _a1 error) *mockStore_DeleteSource_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_DeleteSource_Call) RunAndReturn(run func(context.Context, string) (*model.Source, error)) *mockStore_DeleteSource_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSourceType provides a mock function with given fields: ctx, name
func (_m *mockStore) DeleteSourceType(ctx context.Context, name string) (*model.SourceType, error) {
	ret := _m.Called(ctx, name)

	var r0 *model.SourceType
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.SourceType, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.SourceType); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.SourceType)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_DeleteSourceType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSourceType'
type mockStore_DeleteSourceType_Call struct {
	*mock.Call
}

// DeleteSourceType is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *mockStore_Expecter) DeleteSourceType(ctx interface{}, name interface{}) *mockStore_DeleteSourceType_Call {
	return &mockStore_DeleteSourceType_Call{Call: _e.mock.On("DeleteSourceType", ctx, name)}
}

func (_c *mockStore_DeleteSourceType_Call) Run(run func(ctx context.Context, name string)) *mockStore_DeleteSourceType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_DeleteSourceType_Call) Return(_a0 *model.SourceType, _a1 error) *mockStore_DeleteSourceType_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_DeleteSourceType_Call) RunAndReturn(run func(context.Context, string) (*model.SourceType, error)) *mockStore_DeleteSourceType_Call {
	_c.Call.Return(run)
	return _c
}

// Destination provides a mock function with given fields: ctx, name
func (_m *mockStore) Destination(ctx context.Context, name string) (*model.Destination, error) {
	ret := _m.Called(ctx, name)

	var r0 *model.Destination
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.Destination, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.Destination); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Destination)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_Destination_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Destination'
type mockStore_Destination_Call struct {
	*mock.Call
}

// Destination is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *mockStore_Expecter) Destination(ctx interface{}, name interface{}) *mockStore_Destination_Call {
	return &mockStore_Destination_Call{Call: _e.mock.On("Destination", ctx, name)}
}

func (_c *mockStore_Destination_Call) Run(run func(ctx context.Context, name string)) *mockStore_Destination_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_Destination_Call) Return(_a0 *model.Destination, _a1 error) *mockStore_Destination_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_Destination_Call) RunAndReturn(run func(context.Context, string) (*model.Destination, error)) *mockStore_Destination_Call {
	_c.Call.Return(run)
	return _c
}

// DestinationType provides a mock function with given fields: ctx, name
func (_m *mockStore) DestinationType(ctx context.Context, name string) (*model.DestinationType, error) {
	ret := _m.Called(ctx, name)

	var r0 *model.DestinationType
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.DestinationType, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.DestinationType); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.DestinationType)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_DestinationType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestinationType'
type mockStore_DestinationType_Call struct {
	*mock.Call
}

// DestinationType is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *mockStore_Expecter) DestinationType(ctx interface{}, name interface{}) *mockStore_DestinationType_Call {
	return &mockStore_DestinationType_Call{Call: _e.mock.On("DestinationType", ctx, name)}
}

func (_c *mockStore_DestinationType_Call) Run(run func(ctx context.Context, name string)) *mockStore_DestinationType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_DestinationType_Call) Return(_a0 *model.DestinationType, _a1 error) *mockStore_DestinationType_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_DestinationType_Call) RunAndReturn(run func(context.Context, string) (*model.DestinationType, error)) *mockStore_DestinationType_Call {
	_c.Call.Return(run)
	return _c
}

// DestinationTypes provides a mock function with given fields: ctx
func (_m *mockStore) DestinationTypes(ctx context.Context) ([]*model.DestinationType, error) {
	ret := _m.Called(ctx)

	var r0 []*model.DestinationType
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*model.DestinationType, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*model.DestinationType); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.DestinationType)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_DestinationTypes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestinationTypes'
type mockStore_DestinationTypes_Call struct {
	*mock.Call
}

// DestinationTypes is a helper method to define mock.On call
//   - ctx context.Context
func (_e *mockStore_Expecter) DestinationTypes(ctx interface{}) *mockStore_DestinationTypes_Call {
	return &mockStore_DestinationTypes_Call{Call: _e.mock.On("DestinationTypes", ctx)}
}

func (_c *mockStore_DestinationTypes_Call) Run(run func(ctx context.Context)) *mockStore_DestinationTypes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *mockStore_DestinationTypes_Call) Return(_a0 []*model.DestinationType, _a1 error) *mockStore_DestinationTypes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_DestinationTypes_Call) RunAndReturn(run func(context.Context) ([]*model.DestinationType, error)) *mockStore_DestinationTypes_Call {
	_c.Call.Return(run)
	return _c
}

// Destinations provides a mock function with given fields: ctx
func (_m *mockStore) Destinations(ctx context.Context) ([]*model.Destination, error) {
	ret := _m.Called(ctx)

	var r0 []*model.Destination
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*model.Destination, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*model.Destination); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Destination)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_Destinations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Destinations'
type mockStore_Destinations_Call struct {
	*mock.Call
}

// Destinations is a helper method to define mock.On call
//   - ctx context.Context
func (_e *mockStore_Expecter) Destinations(ctx interface{}) *mockStore_Destinations_Call {
	return &mockStore_Destinations_Call{Call: _e.mock.On("Destinations", ctx)}
}

func (_c *mockStore_Destinations_Call) Run(run func(ctx context.Context)) *mockStore_Destinations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *mockStore_Destinations_Call) Return(_a0 []*model.Destination, _a1 error) *mockStore_Destinations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_Destinations_Call) RunAndReturn(run func(context.Context) ([]*model.Destination, error)) *mockStore_Destinations_Call {
	_c.Call.Return(run)
	return _c
}

// DisconnectUnreportedAgents provides a mock function with given fields: ctx, since
func (_m *mockStore) DisconnectUnreportedAgents(ctx context.Context, since time.Time) error {
	ret := _m.Called(ctx, since)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, time.Time) error); ok {
		r0 = rf(ctx, since)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// mockStore_DisconnectUnreportedAgents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisconnectUnreportedAgents'
type mockStore_DisconnectUnreportedAgents_Call struct {
	*mock.Call
}

// DisconnectUnreportedAgents is a helper method to define mock.On call
//   - ctx context.Context
//   - since time.Time
func (_e *mockStore_Expecter) DisconnectUnreportedAgents(ctx interface{}, since interface{}) *mockStore_DisconnectUnreportedAgents_Call {
	return &mockStore_DisconnectUnreportedAgents_Call{Call: _e.mock.On("DisconnectUnreportedAgents", ctx, since)}
}

func (_c *mockStore_DisconnectUnreportedAgents_Call) Run(run func(ctx context.Context, since time.Time)) *mockStore_DisconnectUnreportedAgents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(time.Time))
	})
	return _c
}

func (_c *mockStore_DisconnectUnreportedAgents_Call) Return(_a0 error) *mockStore_DisconnectUnreportedAgents_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *mockStore_DisconnectUnreportedAgents_Call) RunAndReturn(run func(context.Context, time.Time) error) *mockStore_DisconnectUnreportedAgents_Call {
	_c.Call.Return(run)
	return _c
}

// Measurements provides a mock function with given fields:
func (_m *mockStore) Measurements() stats.Measurements {
	ret := _m.Called()

	var r0 stats.Measurements
	if rf, ok := ret.Get(0).(func() stats.Measurements); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(stats.Measurements)
		}
	}

	return r0
}

// mockStore_Measurements_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Measurements'
type mockStore_Measurements_Call struct {
	*mock.Call
}

// Measurements is a helper method to define mock.On call
func (_e *mockStore_Expecter) Measurements() *mockStore_Measurements_Call {
	return &mockStore_Measurements_Call{Call: _e.mock.On("Measurements")}
}

func (_c *mockStore_Measurements_Call) Run(run func()) *mockStore_Measurements_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *mockStore_Measurements_Call) Return(_a0 stats.Measurements) *mockStore_Measurements_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *mockStore_Measurements_Call) RunAndReturn(run func() stats.Measurements) *mockStore_Measurements_Call {
	_c.Call.Return(run)
	return _c
}

// PauseRollout provides a mock function with given fields: ctx, configurationName
func (_m *mockStore) PauseRollout(ctx context.Context, configurationName string) (*model.Configuration, error) {
	ret := _m.Called(ctx, configurationName)

	var r0 *model.Configuration
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.Configuration, error)); ok {
		return rf(ctx, configurationName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.Configuration); ok {
		r0 = rf(ctx, configurationName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Configuration)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, configurationName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_PauseRollout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PauseRollout'
type mockStore_PauseRollout_Call struct {
	*mock.Call
}

// PauseRollout is a helper method to define mock.On call
//   - ctx context.Context
//   - configurationName string
func (_e *mockStore_Expecter) PauseRollout(ctx interface{}, configurationName interface{}) *mockStore_PauseRollout_Call {
	return &mockStore_PauseRollout_Call{Call: _e.mock.On("PauseRollout", ctx, configurationName)}
}

func (_c *mockStore_PauseRollout_Call) Run(run func(ctx context.Context, configurationName string)) *mockStore_PauseRollout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_PauseRollout_Call) Return(_a0 *model.Configuration, _a1 error) *mockStore_PauseRollout_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_PauseRollout_Call) RunAndReturn(run func(context.Context, string) (*model.Configuration, error)) *mockStore_PauseRollout_Call {
	_c.Call.Return(run)
	return _c
}

// Processor provides a mock function with given fields: ctx, name
func (_m *mockStore) Processor(ctx context.Context, name string) (*model.Processor, error) {
	ret := _m.Called(ctx, name)

	var r0 *model.Processor
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.Processor, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.Processor); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Processor)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_Processor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Processor'
type mockStore_Processor_Call struct {
	*mock.Call
}

// Processor is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *mockStore_Expecter) Processor(ctx interface{}, name interface{}) *mockStore_Processor_Call {
	return &mockStore_Processor_Call{Call: _e.mock.On("Processor", ctx, name)}
}

func (_c *mockStore_Processor_Call) Run(run func(ctx context.Context, name string)) *mockStore_Processor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_Processor_Call) Return(_a0 *model.Processor, _a1 error) *mockStore_Processor_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_Processor_Call) RunAndReturn(run func(context.Context, string) (*model.Processor, error)) *mockStore_Processor_Call {
	_c.Call.Return(run)
	return _c
}

// ProcessorType provides a mock function with given fields: ctx, name
func (_m *mockStore) ProcessorType(ctx context.Context, name string) (*model.ProcessorType, error) {
	ret := _m.Called(ctx, name)

	var r0 *model.ProcessorType
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.ProcessorType, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.ProcessorType); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.ProcessorType)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_ProcessorType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProcessorType'
type mockStore_ProcessorType_Call struct {
	*mock.Call
}

// ProcessorType is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *mockStore_Expecter) ProcessorType(ctx interface{}, name interface{}) *mockStore_ProcessorType_Call {
	return &mockStore_ProcessorType_Call{Call: _e.mock.On("ProcessorType", ctx, name)}
}

func (_c *mockStore_ProcessorType_Call) Run(run func(ctx context.Context, name string)) *mockStore_ProcessorType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_ProcessorType_Call) Return(_a0 *model.ProcessorType, _a1 error) *mockStore_ProcessorType_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_ProcessorType_Call) RunAndReturn(run func(context.Context, string) (*model.ProcessorType, error)) *mockStore_ProcessorType_Call {
	_c.Call.Return(run)
	return _c
}

// ProcessorTypes provides a mock function with given fields: ctx
func (_m *mockStore) ProcessorTypes(ctx context.Context) ([]*model.ProcessorType, error) {
	ret := _m.Called(ctx)

	var r0 []*model.ProcessorType
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*model.ProcessorType, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*model.ProcessorType); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.ProcessorType)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_ProcessorTypes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProcessorTypes'
type mockStore_ProcessorTypes_Call struct {
	*mock.Call
}

// ProcessorTypes is a helper method to define mock.On call
//   - ctx context.Context
func (_e *mockStore_Expecter) ProcessorTypes(ctx interface{}) *mockStore_ProcessorTypes_Call {
	return &mockStore_ProcessorTypes_Call{Call: _e.mock.On("ProcessorTypes", ctx)}
}

func (_c *mockStore_ProcessorTypes_Call) Run(run func(ctx context.Context)) *mockStore_ProcessorTypes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *mockStore_ProcessorTypes_Call) Return(_a0 []*model.ProcessorType, _a1 error) *mockStore_ProcessorTypes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_ProcessorTypes_Call) RunAndReturn(run func(context.Context) ([]*model.ProcessorType, error)) *mockStore_ProcessorTypes_Call {
	_c.Call.Return(run)
	return _c
}

// Processors provides a mock function with given fields: ctx
func (_m *mockStore) Processors(ctx context.Context) ([]*model.Processor, error) {
	ret := _m.Called(ctx)

	var r0 []*model.Processor
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*model.Processor, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*model.Processor); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Processor)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_Processors_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Processors'
type mockStore_Processors_Call struct {
	*mock.Call
}

// Processors is a helper method to define mock.On call
//   - ctx context.Context
func (_e *mockStore_Expecter) Processors(ctx interface{}) *mockStore_Processors_Call {
	return &mockStore_Processors_Call{Call: _e.mock.On("Processors", ctx)}
}

func (_c *mockStore_Processors_Call) Run(run func(ctx context.Context)) *mockStore_Processors_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *mockStore_Processors_Call) Return(_a0 []*model.Processor, _a1 error) *mockStore_Processors_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_Processors_Call) RunAndReturn(run func(context.Context) ([]*model.Processor, error)) *mockStore_Processors_Call {
	_c.Call.Return(run)
	return _c
}

// ReportConnectedAgents provides a mock function with given fields: ctx, agentIDs, _a2
func (_m *mockStore) ReportConnectedAgents(ctx context.Context, agentIDs []string, _a2 time.Time) error {
	ret := _m.Called(ctx, agentIDs, _a2)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, time.Time) error); ok {
		r0 = rf(ctx, agentIDs, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// mockStore_ReportConnectedAgents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReportConnectedAgents'
type mockStore_ReportConnectedAgents_Call struct {
	*mock.Call
}

// ReportConnectedAgents is a helper method to define mock.On call
//   - ctx context.Context
//   - agentIDs []string
//   - _a2 time.Time
func (_e *mockStore_Expecter) ReportConnectedAgents(ctx interface{}, agentIDs interface{}, _a2 interface{}) *mockStore_ReportConnectedAgents_Call {
	return &mockStore_ReportConnectedAgents_Call{Call: _e.mock.On("ReportConnectedAgents", ctx, agentIDs, _a2)}
}

func (_c *mockStore_ReportConnectedAgents_Call) Run(run func(ctx context.Context, agentIDs []string, _a2 time.Time)) *mockStore_ReportConnectedAgents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string), args[2].(time.Time))
	})
	return _c
}

func (_c *mockStore_ReportConnectedAgents_Call) Return(_a0 error) *mockStore_ReportConnectedAgents_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *mockStore_ReportConnectedAgents_Call) RunAndReturn(run func(context.Context, []string, time.Time) error) *mockStore_ReportConnectedAgents_Call {
	_c.Call.Return(run)
	return _c
}

// ResourceHistory provides a mock function with given fields: ctx, resourceKind, resourceName
func (_m *mockStore) ResourceHistory(ctx context.Context, resourceKind model.Kind, resourceName string) ([]*model.AnyResource, error) {
	ret := _m.Called(ctx, resourceKind, resourceName)

	var r0 []*model.AnyResource
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.Kind, string) ([]*model.AnyResource, error)); ok {
		return rf(ctx, resourceKind, resourceName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.Kind, string) []*model.AnyResource); ok {
		r0 = rf(ctx, resourceKind, resourceName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.AnyResource)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.Kind, string) error); ok {
		r1 = rf(ctx, resourceKind, resourceName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_ResourceHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResourceHistory'
type mockStore_ResourceHistory_Call struct {
	*mock.Call
}

// ResourceHistory is a helper method to define mock.On call
//   - ctx context.Context
//   - resourceKind model.Kind
//   - resourceName string
func (_e *mockStore_Expecter) ResourceHistory(ctx interface{}, resourceKind interface{}, resourceName interface{}) *mockStore_ResourceHistory_Call {
	return &mockStore_ResourceHistory_Call{Call: _e.mock.On("ResourceHistory", ctx, resourceKind, resourceName)}
}

func (_c *mockStore_ResourceHistory_Call) Run(run func(ctx context.Context, resourceKind model.Kind, resourceName string)) *mockStore_ResourceHistory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.Kind), args[2].(string))
	})
	return _c
}

func (_c *mockStore_ResourceHistory_Call) Return(_a0 []*model.AnyResource, _a1 error) *mockStore_ResourceHistory_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_ResourceHistory_Call) RunAndReturn(run func(context.Context, model.Kind, string) ([]*model.AnyResource, error)) *mockStore_ResourceHistory_Call {
	_c.Call.Return(run)
	return _c
}

// ResumeRollout provides a mock function with given fields: ctx, configurationName
func (_m *mockStore) ResumeRollout(ctx context.Context, configurationName string) (*model.Configuration, error) {
	ret := _m.Called(ctx, configurationName)

	var r0 *model.Configuration
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.Configuration, error)); ok {
		return rf(ctx, configurationName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.Configuration); ok {
		r0 = rf(ctx, configurationName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Configuration)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, configurationName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_ResumeRollout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResumeRollout'
type mockStore_ResumeRollout_Call struct {
	*mock.Call
}

// ResumeRollout is a helper method to define mock.On call
//   - ctx context.Context
//   - configurationName string
func (_e *mockStore_Expecter) ResumeRollout(ctx interface{}, configurationName interface{}) *mockStore_ResumeRollout_Call {
	return &mockStore_ResumeRollout_Call{Call: _e.mock.On("ResumeRollout", ctx, configurationName)}
}

func (_c *mockStore_ResumeRollout_Call) Run(run func(ctx context.Context, configurationName string)) *mockStore_ResumeRollout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_ResumeRollout_Call) Return(_a0 *model.Configuration, _a1 error) *mockStore_ResumeRollout_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_ResumeRollout_Call) RunAndReturn(run func(context.Context, string) (*model.Configuration, error)) *mockStore_ResumeRollout_Call {
	_c.Call.Return(run)
	return _c
}

// Source provides a mock function with given fields: ctx, name
func (_m *mockStore) Source(ctx context.Context, name string) (*model.Source, error) {
	ret := _m.Called(ctx, name)

	var r0 *model.Source
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.Source, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.Source); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Source)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_Source_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Source'
type mockStore_Source_Call struct {
	*mock.Call
}

// Source is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *mockStore_Expecter) Source(ctx interface{}, name interface{}) *mockStore_Source_Call {
	return &mockStore_Source_Call{Call: _e.mock.On("Source", ctx, name)}
}

func (_c *mockStore_Source_Call) Run(run func(ctx context.Context, name string)) *mockStore_Source_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_Source_Call) Return(_a0 *model.Source, _a1 error) *mockStore_Source_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_Source_Call) RunAndReturn(run func(context.Context, string) (*model.Source, error)) *mockStore_Source_Call {
	_c.Call.Return(run)
	return _c
}

// SourceType provides a mock function with given fields: ctx, name
func (_m *mockStore) SourceType(ctx context.Context, name string) (*model.SourceType, error) {
	ret := _m.Called(ctx, name)

	var r0 *model.SourceType
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.SourceType, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.SourceType); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.SourceType)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_SourceType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SourceType'
type mockStore_SourceType_Call struct {
	*mock.Call
}

// SourceType is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *mockStore_Expecter) SourceType(ctx interface{}, name interface{}) *mockStore_SourceType_Call {
	return &mockStore_SourceType_Call{Call: _e.mock.On("SourceType", ctx, name)}
}

func (_c *mockStore_SourceType_Call) Run(run func(ctx context.Context, name string)) *mockStore_SourceType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_SourceType_Call) Return(_a0 *model.SourceType, _a1 error) *mockStore_SourceType_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_SourceType_Call) RunAndReturn(run func(context.Context, string) (*model.SourceType, error)) *mockStore_SourceType_Call {
	_c.Call.Return(run)
	return _c
}

// SourceTypes provides a mock function with given fields: ctx
func (_m *mockStore) SourceTypes(ctx context.Context) ([]*model.SourceType, error) {
	ret := _m.Called(ctx)

	var r0 []*model.SourceType
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*model.SourceType, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*model.SourceType); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.SourceType)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_SourceTypes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SourceTypes'
type mockStore_SourceTypes_Call struct {
	*mock.Call
}

// SourceTypes is a helper method to define mock.On call
//   - ctx context.Context
func (_e *mockStore_Expecter) SourceTypes(ctx interface{}) *mockStore_SourceTypes_Call {
	return &mockStore_SourceTypes_Call{Call: _e.mock.On("SourceTypes", ctx)}
}

func (_c *mockStore_SourceTypes_Call) Run(run func(ctx context.Context)) *mockStore_SourceTypes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *mockStore_SourceTypes_Call) Return(_a0 []*model.SourceType, _a1 error) *mockStore_SourceTypes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_SourceTypes_Call) RunAndReturn(run func(context.Context) ([]*model.SourceType, error)) *mockStore_SourceTypes_Call {
	_c.Call.Return(run)
	return _c
}

// Sources provides a mock function with given fields: ctx
func (_m *mockStore) Sources(ctx context.Context) ([]*model.Source, error) {
	ret := _m.Called(ctx)

	var r0 []*model.Source
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*model.Source, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*model.Source); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Source)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_Sources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Sources'
type mockStore_Sources_Call struct {
	*mock.Call
}

// Sources is a helper method to define mock.On call
//   - ctx context.Context
func (_e *mockStore_Expecter) Sources(ctx interface{}) *mockStore_Sources_Call {
	return &mockStore_Sources_Call{Call: _e.mock.On("Sources", ctx)}
}

func (_c *mockStore_Sources_Call) Run(run func(ctx context.Context)) *mockStore_Sources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *mockStore_Sources_Call) Return(_a0 []*model.Source, _a1 error) *mockStore_Sources_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_Sources_Call) RunAndReturn(run func(context.Context) ([]*model.Source, error)) *mockStore_Sources_Call {
	_c.Call.Return(run)
	return _c
}

// StartRollout provides a mock function with given fields: ctx, configurationName, options
func (_m *mockStore) StartRollout(ctx context.Context, configurationName string, options *model.RolloutOptions) (*model.Configuration, error) {
	ret := _m.Called(ctx, configurationName, options)

	var r0 *model.Configuration
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *model.RolloutOptions) (*model.Configuration, error)); ok {
		return rf(ctx, configurationName, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *model.RolloutOptions) *model.Configuration); ok {
		r0 = rf(ctx, configurationName, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Configuration)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *model.RolloutOptions) error); ok {
		r1 = rf(ctx, configurationName, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_StartRollout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartRollout'
type mockStore_StartRollout_Call struct {
	*mock.Call
}

// StartRollout is a helper method to define mock.On call
//   - ctx context.Context
//   - configurationName string
//   - options *model.RolloutOptions
func (_e *mockStore_Expecter) StartRollout(ctx interface{}, configurationName interface{}, options interface{}) *mockStore_StartRollout_Call {
	return &mockStore_StartRollout_Call{Call: _e.mock.On("StartRollout", ctx, configurationName, options)}
}

func (_c *mockStore_StartRollout_Call) Run(run func(ctx context.Context, configurationName string, options *model.RolloutOptions)) *mockStore_StartRollout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*model.RolloutOptions))
	})
	return _c
}

func (_c *mockStore_StartRollout_Call) Return(_a0 *model.Configuration, _a1 error) *mockStore_StartRollout_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_StartRollout_Call) RunAndReturn(run func(context.Context, string, *model.RolloutOptions) (*model.Configuration, error)) *mockStore_StartRollout_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateAgent provides a mock function with given fields: ctx, agentID, updater
func (_m *mockStore) UpdateAgent(ctx context.Context, agentID string, updater AgentUpdater) (*model.Agent, error) {
	ret := _m.Called(ctx, agentID, updater)

	var r0 *model.Agent
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, AgentUpdater) (*model.Agent, error)); ok {
		return rf(ctx, agentID, updater)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, AgentUpdater) *model.Agent); ok {
		r0 = rf(ctx, agentID, updater)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Agent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, AgentUpdater) error); ok {
		r1 = rf(ctx, agentID, updater)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_UpdateAgent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAgent'
type mockStore_UpdateAgent_Call struct {
	*mock.Call
}

// UpdateAgent is a helper method to define mock.On call
//   - ctx context.Context
//   - agentID string
//   - updater AgentUpdater
func (_e *mockStore_Expecter) UpdateAgent(ctx interface{}, agentID interface{}, updater interface{}) *mockStore_UpdateAgent_Call {
	return &mockStore_UpdateAgent_Call{Call: _e.mock.On("UpdateAgent", ctx, agentID, updater)}
}

func (_c *mockStore_UpdateAgent_Call) Run(run func(ctx context.Context, agentID string, updater AgentUpdater)) *mockStore_UpdateAgent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(AgentUpdater))
	})
	return _c
}

func (_c *mockStore_UpdateAgent_Call) Return(_a0 *model.Agent, _a1 error) *mockStore_UpdateAgent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_UpdateAgent_Call) RunAndReturn(run func(context.Context, string, AgentUpdater) (*model.Agent, error)) *mockStore_UpdateAgent_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateAgentStatus provides a mock function with given fields: ctx, agentID, status
func (_m *mockStore) UpdateAgentStatus(ctx context.Context, agentID string, status model.AgentStatus) error {
	ret := _m.Called(ctx, agentID, status)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, model.AgentStatus) error); ok {
		r0 = rf(ctx, agentID, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// mockStore_UpdateAgentStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAgentStatus'
type mockStore_UpdateAgentStatus_Call struct {
	*mock.Call
}

// UpdateAgentStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - agentID string
//   - status model.AgentStatus
func (_e *mockStore_Expecter) UpdateAgentStatus(ctx interface{}, agentID interface{}, status interface{}) *mockStore_UpdateAgentStatus_Call {
	return &mockStore_UpdateAgentStatus_Call{Call: _e.mock.On("UpdateAgentStatus", ctx, agentID, status)}
}

func (_c *mockStore_UpdateAgentStatus_Call) Run(run func(ctx context.Context, agentID string, status model.AgentStatus)) *mockStore_UpdateAgentStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(model.AgentStatus))
	})
	return _c
}

func (_c *mockStore_UpdateAgentStatus_Call) Return(_a0 error) *mockStore_UpdateAgentStatus_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *mockStore_UpdateAgentStatus_Call) RunAndReturn(run func(context.Context, string, model.AgentStatus) error) *mockStore_UpdateAgentStatus_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateAgents provides a mock function with given fields: ctx, agentIDs, updater
func (_m *mockStore) UpdateAgents(ctx context.Context, agentIDs []string, updater AgentUpdater) ([]*model.Agent, error) {
	ret := _m.Called(ctx, agentIDs, updater)

	var r0 []*model.Agent
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, AgentUpdater) ([]*model.Agent, error)); ok {
		return rf(ctx, agentIDs, updater)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, AgentUpdater) []*model.Agent); ok {
		r0 = rf(ctx, agentIDs, updater)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Agent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, AgentUpdater) error); ok {
		r1 = rf(ctx, agentIDs, updater)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_UpdateAgents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAgents'
type mockStore_UpdateAgents_Call struct {
	*mock.Call
}

// UpdateAgents is a helper method to define mock.On call
//   - ctx context.Context
//   - agentIDs []string
//   - updater AgentUpdater
func (_e *mockStore_Expecter) UpdateAgents(ctx interface{}, agentIDs interface{}, updater interface{}) *mockStore_UpdateAgents_Call {
	return &mockStore_UpdateAgents_Call{Call: _e.mock.On("UpdateAgents", ctx, agentIDs, updater)}
}

func (_c *mockStore_UpdateAgents_Call) Run(run func(ctx context.Context, agentIDs []string, updater AgentUpdater)) *mockStore_UpdateAgents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string), args[2].(AgentUpdater))
	})
	return _c
}

func (_c *mockStore_UpdateAgents_Call) Return(_a0 []*model.Agent, _a1 error) *mockStore_UpdateAgents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_UpdateAgents_Call) RunAndReturn(run func(context.Context, []string, AgentUpdater) ([]*model.Agent, error)) *mockStore_UpdateAgents_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateAllRollouts provides a mock function with given fields: ctx
func (_m *mockStore) UpdateAllRollouts(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// mockStore_UpdateAllRollouts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAllRollouts'
type mockStore_UpdateAllRollouts_Call struct {
	*mock.Call
}

// UpdateAllRollouts is a helper method to define mock.On call
//   - ctx context.Context
func (_e *mockStore_Expecter) UpdateAllRollouts(ctx interface{}) *mockStore_UpdateAllRollouts_Call {
	return &mockStore_UpdateAllRollouts_Call{Call: _e.mock.On("UpdateAllRollouts", ctx)}
}

func (_c *mockStore_UpdateAllRollouts_Call) Run(run func(ctx context.Context)) *mockStore_UpdateAllRollouts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *mockStore_UpdateAllRollouts_Call) Return(_a0 error) *mockStore_UpdateAllRollouts_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *mockStore_UpdateAllRollouts_Call) RunAndReturn(run func(context.Context) error) *mockStore_UpdateAllRollouts_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateConfiguration provides a mock function with given fields: ctx, name, updater
func (_m *mockStore) UpdateConfiguration(ctx context.Context, name string, updater ConfigurationUpdater) (*model.Configuration, model.UpdateStatus, error) {
	ret := _m.Called(ctx, name, updater)

	var r0 *model.Configuration
	var r1 model.UpdateStatus
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ConfigurationUpdater) (*model.Configuration, model.UpdateStatus, error)); ok {
		return rf(ctx, name, updater)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ConfigurationUpdater) *model.Configuration); ok {
		r0 = rf(ctx, name, updater)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Configuration)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ConfigurationUpdater) model.UpdateStatus); ok {
		r1 = rf(ctx, name, updater)
	} else {
		r1 = ret.Get(1).(model.UpdateStatus)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ConfigurationUpdater) error); ok {
		r2 = rf(ctx, name, updater)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// mockStore_UpdateConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateConfiguration'
type mockStore_UpdateConfiguration_Call struct {
	*mock.Call
}

// UpdateConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - updater ConfigurationUpdater
func (_e *mockStore_Expecter) UpdateConfiguration(ctx interface{}, name interface{}, updater interface{}) *mockStore_UpdateConfiguration_Call {
	return &mockStore_UpdateConfiguration_Call{Call: _e.mock.On("UpdateConfiguration", ctx, name, updater)}
}

func (_c *mockStore_UpdateConfiguration_Call) Run(run func(ctx context.Context, name string, updater ConfigurationUpdater)) *mockStore_UpdateConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(ConfigurationUpdater))
	})
	return _c
}

func (_c *mockStore_UpdateConfiguration_Call) Return(config *model.Configuration, status model.UpdateStatus, err error) *mockStore_UpdateConfiguration_Call {
	_c.Call.Return(config, status, err)
	return _c
}

func (_c *mockStore_UpdateConfiguration_Call) RunAndReturn(run func(context.Context, string, ConfigurationUpdater) (*model.Configuration, model.UpdateStatus, error)) *mockStore_UpdateConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRollout provides a mock function with given fields: ctx, configurationName
func (_m *mockStore) UpdateRollout(ctx context.Context, configurationName string) (*model.Configuration, error) {
	ret := _m.Called(ctx, configurationName)

	var r0 *model.Configuration
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.Configuration, error)); ok {
		return rf(ctx, configurationName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.Configuration); ok {
		r0 = rf(ctx, configurationName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Configuration)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, configurationName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_UpdateRollout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRollout'
type mockStore_UpdateRollout_Call struct {
	*mock.Call
}

// UpdateRollout is a helper method to define mock.On call
//   - ctx context.Context
//   - configurationName string
func (_e *mockStore_Expecter) UpdateRollout(ctx interface{}, configurationName interface{}) *mockStore_UpdateRollout_Call {
	return &mockStore_UpdateRollout_Call{Call: _e.mock.On("UpdateRollout", ctx, configurationName)}
}

func (_c *mockStore_UpdateRollout_Call) Run(run func(ctx context.Context, configurationName string)) *mockStore_UpdateRollout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *mockStore_UpdateRollout_Call) Return(_a0 *model.Configuration, _a1 error) *mockStore_UpdateRollout_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_UpdateRollout_Call) RunAndReturn(run func(context.Context, string) (*model.Configuration, error)) *mockStore_UpdateRollout_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRollouts provides a mock function with given fields: ctx
func (_m *mockStore) UpdateRollouts(ctx context.Context) ([]*model.Configuration, error) {
	ret := _m.Called(ctx)

	var r0 []*model.Configuration
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*model.Configuration, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*model.Configuration); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Configuration)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_UpdateRollouts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRollouts'
type mockStore_UpdateRollouts_Call struct {
	*mock.Call
}

// UpdateRollouts is a helper method to define mock.On call
//   - ctx context.Context
func (_e *mockStore_Expecter) UpdateRollouts(ctx interface{}) *mockStore_UpdateRollouts_Call {
	return &mockStore_UpdateRollouts_Call{Call: _e.mock.On("UpdateRollouts", ctx)}
}

func (_c *mockStore_UpdateRollouts_Call) Run(run func(ctx context.Context)) *mockStore_UpdateRollouts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *mockStore_UpdateRollouts_Call) Return(_a0 []*model.Configuration, _a1 error) *mockStore_UpdateRollouts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_UpdateRollouts_Call) RunAndReturn(run func(context.Context) ([]*model.Configuration, error)) *mockStore_UpdateRollouts_Call {
	_c.Call.Return(run)
	return _c
}

// Updates provides a mock function with given fields: ctx
func (_m *mockStore) Updates(ctx context.Context) eventbus.Source[BasicEventUpdates] {
	ret := _m.Called(ctx)

	var r0 eventbus.Source[BasicEventUpdates]
	if rf, ok := ret.Get(0).(func(context.Context) eventbus.Source[BasicEventUpdates]); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(eventbus.Source[BasicEventUpdates])
		}
	}

	return r0
}

// mockStore_Updates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Updates'
type mockStore_Updates_Call struct {
	*mock.Call
}

// Updates is a helper method to define mock.On call
//   - ctx context.Context
func (_e *mockStore_Expecter) Updates(ctx interface{}) *mockStore_Updates_Call {
	return &mockStore_Updates_Call{Call: _e.mock.On("Updates", ctx)}
}

func (_c *mockStore_Updates_Call) Run(run func(ctx context.Context)) *mockStore_Updates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *mockStore_Updates_Call) Return(_a0 eventbus.Source[BasicEventUpdates]) *mockStore_Updates_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *mockStore_Updates_Call) RunAndReturn(run func(context.Context) eventbus.Source[BasicEventUpdates]) *mockStore_Updates_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertAgent provides a mock function with given fields: ctx, agentID, updater
func (_m *mockStore) UpsertAgent(ctx context.Context, agentID string, updater AgentUpdater) (*model.Agent, error) {
	ret := _m.Called(ctx, agentID, updater)

	var r0 *model.Agent
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, AgentUpdater) (*model.Agent, error)); ok {
		return rf(ctx, agentID, updater)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, AgentUpdater) *model.Agent); ok {
		r0 = rf(ctx, agentID, updater)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Agent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, AgentUpdater) error); ok {
		r1 = rf(ctx, agentID, updater)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_UpsertAgent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertAgent'
type mockStore_UpsertAgent_Call struct {
	*mock.Call
}

// UpsertAgent is a helper method to define mock.On call
//   - ctx context.Context
//   - agentID string
//   - updater AgentUpdater
func (_e *mockStore_Expecter) UpsertAgent(ctx interface{}, agentID interface{}, updater interface{}) *mockStore_UpsertAgent_Call {
	return &mockStore_UpsertAgent_Call{Call: _e.mock.On("UpsertAgent", ctx, agentID, updater)}
}

func (_c *mockStore_UpsertAgent_Call) Run(run func(ctx context.Context, agentID string, updater AgentUpdater)) *mockStore_UpsertAgent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(AgentUpdater))
	})
	return _c
}

func (_c *mockStore_UpsertAgent_Call) Return(_a0 *model.Agent, _a1 error) *mockStore_UpsertAgent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_UpsertAgent_Call) RunAndReturn(run func(context.Context, string, AgentUpdater) (*model.Agent, error)) *mockStore_UpsertAgent_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertAgents provides a mock function with given fields: ctx, agentIDs, updater
func (_m *mockStore) UpsertAgents(ctx context.Context, agentIDs []string, updater AgentUpdater) ([]*model.Agent, error) {
	ret := _m.Called(ctx, agentIDs, updater)

	var r0 []*model.Agent
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, AgentUpdater) ([]*model.Agent, error)); ok {
		return rf(ctx, agentIDs, updater)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, AgentUpdater) []*model.Agent); ok {
		r0 = rf(ctx, agentIDs, updater)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Agent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, AgentUpdater) error); ok {
		r1 = rf(ctx, agentIDs, updater)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockStore_UpsertAgents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertAgents'
type mockStore_UpsertAgents_Call struct {
	*mock.Call
}

// UpsertAgents is a helper method to define mock.On call
//   - ctx context.Context
//   - agentIDs []string
//   - updater AgentUpdater
func (_e *mockStore_Expecter) UpsertAgents(ctx interface{}, agentIDs interface{}, updater interface{}) *mockStore_UpsertAgents_Call {
	return &mockStore_UpsertAgents_Call{Call: _e.mock.On("UpsertAgents", ctx, agentIDs, updater)}
}

func (_c *mockStore_UpsertAgents_Call) Run(run func(ctx context.Context, agentIDs []string, updater AgentUpdater)) *mockStore_UpsertAgents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string), args[2].(AgentUpdater))
	})
	return _c
}

func (_c *mockStore_UpsertAgents_Call) Return(_a0 []*model.Agent, _a1 error) *mockStore_UpsertAgents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockStore_UpsertAgents_Call) RunAndReturn(run func(context.Context, []string, AgentUpdater) ([]*model.Agent, error)) *mockStore_UpsertAgents_Call {
	_c.Call.Return(run)
	return _c
}

// UserSessions provides a mock function with given fields:
func (_m *mockStore) UserSessions() sessions.Store {
	ret := _m.Called()

	var r0 sessions.Store
	if rf, ok := ret.Get(0).(func() sessions.Store); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(sessions.Store)
		}
	}

	return r0
}

// mockStore_UserSessions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UserSessions'
type mockStore_UserSessions_Call struct {
	*mock.Call
}

// UserSessions is a helper method to define mock.On call
func (_e *mockStore_Expecter) UserSessions() *mockStore_UserSessions_Call {
	return &mockStore_UserSessions_Call{Call: _e.mock.On("UserSessions")}
}

func (_c *mockStore_UserSessions_Call) Run(run func()) *mockStore_UserSessions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *mockStore_UserSessions_Call) Return(_a0 sessions.Store) *mockStore_UserSessions_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *mockStore_UserSessions_Call) RunAndReturn(run func() sessions.Store) *mockStore_UserSessions_Call {
	_c.Call.Return(run)
	return _c
}

// newMockStore creates a new instance of mockStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockStore {
	mock := &mockStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
